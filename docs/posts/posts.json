[
  {
    "path": "posts/2020-12-11-day-3/",
    "title": "Day #3",
    "description": "Advent of code 2020 day 3",
    "author": [
      {
        "name": "Philippe Massicotte",
        "url": {}
      }
    ],
    "date": "2020-12-11",
    "categories": [],
    "contents": "\nContext\nhttps://adventofcode.com/2020/day/3\n With the toboggan login problems resolved, you set off toward the airport. While travel by toboggan might be easy, it’s certainly not safe: there’s very minimal steering and the area is covered in trees. You’ll need to see which angles will take you near the fewest trees.\nDue to the local geology, trees in this area only grow on exact integer coordinates in a grid. You make a map (your puzzle input) of the open squares (.) and trees (#) you can see. For example:\n..##.......\n#...#...#..\n.#....#..#.\n..#.#...#.#\n.#...##..#.\n..#.##.....\n.#.#.#....#\n.#........#\n#.##...#...\n#...##....#\n.#..#...#.#\n\nRead the input map\n\n\nfile <- here(\"data\", \"input\", \"day3.txt\")\n\nx <- read_lines(file)\n\nm <- str_split(x, pattern = \"\") %>%\n  do.call(rbind, .)\n\ndim(m)\n\n\n[1] 323  31\n\nhead(m)\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n[1,] \".\"  \"#\"  \"#\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \"#\"   \".\"   \"#\"  \n[2,] \".\"  \".\"  \".\"  \"#\"  \"#\"  \".\"  \".\"  \".\"  \".\"  \".\"   \"#\"   \".\"  \n[3,] \"#\"  \".\"  \".\"  \".\"  \".\"  \"#\"  \"#\"  \".\"  \".\"  \".\"   \".\"   \"#\"  \n[4,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \"#\"  \".\"  \"#\"   \"#\"   \"#\"  \n[5,] \"#\"  \"#\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"   \".\"   \".\"  \n[6,] \"#\"  \"#\"  \"#\"  \".\"  \"#\"  \".\"  \"#\"  \".\"  \"#\"  \".\"   \".\"   \".\"  \n     [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]\n[1,] \"#\"   \".\"   \".\"   \"#\"   \".\"   \".\"   \"#\"   \".\"   \".\"   \"#\"  \n[2,] \".\"   \".\"   \"#\"   \"#\"   \"#\"   \".\"   \".\"   \".\"   \".\"   \".\"  \n[3,] \".\"   \".\"   \".\"   \".\"   \".\"   \"#\"   \".\"   \".\"   \".\"   \".\"  \n[4,] \".\"   \"#\"   \".\"   \".\"   \".\"   \".\"   \".\"   \".\"   \"#\"   \".\"  \n[5,] \"#\"   \".\"   \".\"   \".\"   \".\"   \"#\"   \".\"   \"#\"   \".\"   \".\"  \n[6,] \".\"   \".\"   \".\"   \"#\"   \"#\"   \".\"   \".\"   \".\"   \"#\"   \".\"  \n     [,23] [,24] [,25] [,26] [,27] [,28] [,29] [,30] [,31]\n[1,] \"#\"   \".\"   \".\"   \".\"   \".\"   \"#\"   \".\"   \".\"   \".\"  \n[2,] \".\"   \".\"   \".\"   \"#\"   \"#\"   \"#\"   \".\"   \".\"   \".\"  \n[3,] \".\"   \"#\"   \".\"   \".\"   \"#\"   \"#\"   \".\"   \"#\"   \"#\"  \n[4,] \".\"   \"#\"   \".\"   \".\"   \"#\"   \".\"   \".\"   \"#\"   \".\"  \n[5,] \".\"   \"#\"   \".\"   \".\"   \".\"   \".\"   \".\"   \".\"   \".\"  \n[6,] \".\"   \".\"   \".\"   \".\"   \".\"   \".\"   \".\"   \".\"   \".\"  \n\nPart 1\nCreate position vector\nThe rules for the first part are:\n\nThe toboggan can only follow a few specific slopes (you opted for a cheaper model that prefers rational numbers); start by counting all the trees you would encounter for the slope right 3, down 1.\n\n\n\nstart_i <- 1\nstart_j <- 1\n\ndelta_i <- 1\ndelta_j <- 3\n\n\n\nDuplicate the matrix\nWe need to have at least as many columns as rows.\n\n\ntimes <- ceiling(dim(m)[1] / dim(m)[2]) * delta_j\nm <- matrix(rep(m, times), ncol = times * ncol(m), byrow = F)\n\ndim(m)\n\n\n[1]  323 1023\n\n\n\ni <- seq((start_i + delta_i), nrow(m), by = delta_i) # lines\nj <- seq((start_j + delta_j), ncol(m), by = delta_j) # columns\n\nj <- j[1:length(i)]\n\n\n\nCount the number of trees\n\n\nobject <- m[cbind(i, j)]\nsum(str_count(object, \"#\"), na.rm = TRUE)\n\n\n[1] 265\n\nPart 2\nThe second part is exactly the same as for part 1 but with different rules (or scenarios).\nRight 1, down 1.\nRight 3, down 1. (This is the slope you already checked.)\nRight 5, down 1.\nRight 7, down 1.\nRight 1, down 2.\nLets turn the previous code into a function.\n\n\ncount_trees <- function(delta_i, delta_j, m, start_i, start_j) {\n  times <- ceiling(dim(m)[1] / dim(m)[2]) * delta_j\n  m <- matrix(rep(m, times), ncol = times * ncol(m), byrow = F)\n\n  i <- seq((start_i + delta_i), nrow(m), by = delta_i) # lines\n  j <- seq((start_j + delta_j), ncol(m), by = delta_j) # columns\n\n  j <- j[1:length(i)]\n\n  object <- m[cbind(i, j)]\n\n  ntrees <- sum(str_count(object, \"#\"), na.rm = TRUE)\n\n  return(ntrees)\n}\n\n\n\nNow we can define the three new scenarios:\n\n\n# Define the scenarios\nright <- c(1, 3, 5, 7, 1)\ndown <- c(1, 1, 1, 1, 2)\nstart_i <- 1\nstart_j <- 1\n\nfile <- here(\"data\", \"input\", \"day3.txt\")\nx <- read_lines(file)\nm <- str_split(x, pattern = \"\") %>%\n  do.call(rbind, .)\n\ntrees <- pmap_int(\n  list(down, right),\n  count_trees,\n  m = m,\n  start_i = start_i,\n  start_j = start_j\n)\n\ntrees\n\n\n[1]  61 265  82  70  34\n\nAnd finally we need to multiply all the numbers.\n\n\nprod(trees)\n\n\n[1] 3154761400\n\n\n\n\n",
    "preview": {},
    "last_modified": "2020-12-11T10:21:11-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-12-10-day-1/",
    "title": "Day #1",
    "description": "Advent of code 2020 day 1",
    "author": [
      {
        "name": "Philippe Massicotte",
        "url": {}
      }
    ],
    "date": "2020-12-10",
    "categories": [],
    "contents": "\nContext\nhttps://adventofcode.com/2020/day/1\n After saving Christmas five years in a row, you’ve decided to take a vacation at a nice resort on a tropical island. Surely, Christmas will go on without you.\nThe tropical island has its own currency and is entirely cash-only. The gold coins used there have a little picture of a starfish; the locals just call them stars. None of the currency exchanges seem to have heard of them, but somehow, you’ll need to find fifty of these coins by the time you arrive so you can pay the deposit on your room.\nTo save your vacation, you need to get all fifty stars by December 25th.\nCollect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\nBefore you leave, the Elves in accounting just need you to fix your expense report (your puzzle input); apparently, something isn’t quite adding up.\nSpecifically, they need you to find the two entries that sum to 2020 and then multiply those two numbers together. \nRead the input numbers\n\n\nfile <- here(\"data\", \"input\", \"day1.txt\")\n\nx <- read_lines(file) %>% \n  parse_number()\n\nx\n\n\n  [1] 1655 1384 1752 1919 1972 1766 1852 1835 1408 1721 1879 1846 1394\n [14] 1577 1588 1097 1748 1585  765 1375 1806 1785 1824 1847 1037 1531\n [27] 1989 1570 1625 1600 1832 1927 1691 1593 1936 1812  570 1391 1883\n [40] 1592 1875 1185 1903  855 1331 1742 1884 1356 1944 1994 1556 1271\n [53] 1572 1661 1914 1905 1581 1634 1252 1657  989 1907 1998 1040 1833\n [66] 1612 1725 1680 1869 1900 1550 1768 1727 1930 1810 1841  734 1779\n [79] 1774 1825 1446 1259 1552 1310 1885 1689 1929 1959  787 1642 1890\n [92] 1164 1986 1796 1465 1217 1741 1480 1683 1808 1058 1970 1361 2003\n[105] 1898 1668 1754 1773 1235 1158 1975 1479 1995 1648 1023  883 1553\n[118] 1658 1794 1747 1978 1268 1966 1192 1886 1471 1548 1819 1551 1958\n[131] 1732 1676 1745 1501 1858 1652 1596  473 1314 1814 1409 1877 1344\n[144] 1735 1635 1273  871 1643 1599 1565 1695 1803 1764 1778 1823 1831\n[157] 1701  282 1089 1623 1639 1568 1469 1674 1818 1992 1597 1711 1359\n[170] 1851 1496 1630 1755 1529 1881 1718 1916 1325 1578 1441 1722 1545\n[183] 1472 1783 1497 1791 1183 1926 1937 1255 1095 1451 1395 1665 1432\n[196] 1693 1821 1938 1941 2002\n\nFind all combinations of 2 elements\n\n\nm <- 3\n\ncol_names <- paste0(\"x\", 1:m)\n\ndf <- combn(x, m = m) %>% \n  t() %>% \n  as_tibble() %>% \n  set_names(col_names)\n\ndf\n\n\n# A tibble: 1,313,400 x 3\n      x1    x2    x3\n   <dbl> <dbl> <dbl>\n 1  1655  1384  1752\n 2  1655  1384  1919\n 3  1655  1384  1972\n 4  1655  1384  1766\n 5  1655  1384  1852\n 6  1655  1384  1835\n 7  1655  1384  1408\n 8  1655  1384  1721\n 9  1655  1384  1879\n10  1655  1384  1846\n# … with 1,313,390 more rows\n\nCalculate the sum\n\n\ndf <- df %>% \n  mutate(total = rowSums(.))\n\ndf\n\n\n# A tibble: 1,313,400 x 4\n      x1    x2    x3 total\n   <dbl> <dbl> <dbl> <dbl>\n 1  1655  1384  1752  4791\n 2  1655  1384  1919  4958\n 3  1655  1384  1972  5011\n 4  1655  1384  1766  4805\n 5  1655  1384  1852  4891\n 6  1655  1384  1835  4874\n 7  1655  1384  1408  4447\n 8  1655  1384  1721  4760\n 9  1655  1384  1879  4918\n10  1655  1384  1846  4885\n# … with 1,313,390 more rows\n\nExtract the line with the sum equal to 2020\n\n\ndf <- df %>% \n  filter(total == 2020)\n\ndf\n\n\n# A tibble: 1 x 4\n     x1    x2    x3 total\n  <dbl> <dbl> <dbl> <dbl>\n1   855   883   282  2020\n\nCalculate the product\n\n\ndf <- df %>% \n  rowwise() %>% \n  mutate(total = prod(c_across(starts_with(\"x\"))))\n\ndf\n\n\n# A tibble: 1 x 4\n# Rowwise: \n     x1    x2    x3     total\n  <dbl> <dbl> <dbl>     <dbl>\n1   855   883   282 212900130\n\nAnswer\nThe answer is 212900130.\n\n\n\n",
    "preview": {},
    "last_modified": "2020-12-10T17:56:30-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-12-10-day-2/",
    "title": "Day #2",
    "description": "Advent of code 2020 day 2",
    "author": [
      {
        "name": "Philippe Massicotte",
        "url": {}
      }
    ],
    "date": "2020-12-10",
    "categories": [],
    "contents": "\nContext\nhttps://adventofcode.com/2020/day/2\n Your flight departs in a few days from the coastal airport; the easiest way down to the coast from here is via toboggan.\nThe shopkeeper at the North Pole Toboggan Rental Shop is having a bad day. “Something’s wrong with our computers; we can’t log in!” You ask if you can take a look.\nTheir password database seems to be a little corrupted: some of the passwords wouldn’t have been allowed by the Official Toboggan Corporate Policy that was in effect when they were chosen.\nTo try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set.\nFor example, suppose you have the following list:\n1-3 a: abcde 1-3 b: cdefg 2-9 c: ccccccccc Each line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times.\nIn the above example, 2 passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies.\nHow many passwords are valid according to their policies? \nRead the input passwords\n\n\nfile <- here(\"data\", \"input\", \"day2.txt\")\n\nx <- read_lines(file) \n\ndf <- tibble(x)\n\ndf\n\n\n# A tibble: 1,000 x 1\n   x                         \n   <chr>                     \n 1 4-6 b: bbbdbtbbbj         \n 2 1-6 g: ggvggbgggstg       \n 3 1-4 s: lssss              \n 4 13-14 v: hvvcvvvvvvvvvsvvv\n 5 3-5 m: lcmmm              \n 6 3-4 t: stht               \n 7 5-6 b: dbkbhb             \n 8 4-7 p: ppfppppq           \n 9 4-5 j: jjjjj              \n10 3-12 s: sskssssssssss     \n# … with 990 more rows\n\nPrepare the data\n\n\ndf <- df %>% \n  separate(x, into = c(\"policy\", \"password\"), sep = \":\") %>% \n  mutate(across(where(is.character), str_squish)) %>% \n  separate(policy, into = c(\"min\", \"max\", \"letter\"), sep = \"-| \", convert = TRUE)\n\ndf\n\n\n# A tibble: 1,000 x 4\n     min   max letter password         \n   <int> <int> <chr>  <chr>            \n 1     4     6 b      bbbdbtbbbj       \n 2     1     6 g      ggvggbgggstg     \n 3     1     4 s      lssss            \n 4    13    14 v      hvvcvvvvvvvvvsvvv\n 5     3     5 m      lcmmm            \n 6     3     4 t      stht             \n 7     5     6 b      dbkbhb           \n 8     4     7 p      ppfppppq         \n 9     4     5 j      jjjjj            \n10     3    12 s      sskssssssssss    \n# … with 990 more rows\n\nVerify passwords (part 1)\n\n\ndf %>% \n  mutate(count = str_count(password, letter)) %>% \n  rowwise() %>% \n  filter(between(count, min, max))\n\n\n# A tibble: 454 x 5\n# Rowwise: \n     min   max letter password            count\n   <int> <int> <chr>  <chr>               <int>\n 1     1     4 s      lssss                   4\n 2    13    14 v      hvvcvvvvvvvvvsvvv      14\n 3     3     5 m      lcmmm                   3\n 4     4     7 p      ppfppppq                6\n 5     4     5 j      jjjjj                   5\n 6     3    12 s      sskssssssssss          12\n 7    12    18 l      tllllllllllllplllbl    16\n 8     1     2 n      nbnj                    2\n 9     6     9 n      nnnnnnnnb               8\n10     8    18 d      ddtdddddddwvdfdsdd     13\n# … with 444 more rows\n\nVerify passwords (part 2)\n\n\ndf %>% \n  mutate(location_1 = str_sub(password, min, min)) %>% \n  mutate(location_2 = str_sub(password, max, max)) %>% \n  rowwise() %>% \n  filter((letter == location_1 | letter == location_2) & (location_1 != location_2))\n\n\n# A tibble: 649 x 6\n# Rowwise: \n     min   max letter password            location_1 location_2\n   <int> <int> <chr>  <chr>               <chr>      <chr>     \n 1     1     6 g      ggvggbgggstg        g          b         \n 2     1     4 s      lssss               l          s         \n 3    13    14 v      hvvcvvvvvvvvvsvvv   v          s         \n 4     3     4 t      stht                h          t         \n 5     5     6 b      dbkbhb              h          b         \n 6     3    12 s      sskssssssssss       k          s         \n 7    14    15 z      zrndzbmrzzpzzqzj    q          z         \n 8    12    18 l      tllllllllllllplllbl l          b         \n 9     1     2 n      nbnj                n          b         \n10     6     9 n      nnnnnnnnb           n          b         \n# … with 639 more rows\n\n\n\n\n",
    "preview": {},
    "last_modified": "2020-12-11T07:40:27-05:00",
    "input_file": {}
  }
]
